// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAMERA_RUFF_PHOTOGRAMMETRY_H_
#define FLATBUFFERS_GENERATED_CAMERA_RUFF_PHOTOGRAMMETRY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "../models/camera.hpp"

namespace ruff {
namespace photogrammetry {

struct IntrinsicsBuf;

struct ExtrinsicsBuf;

struct DistortionCoeffsBuf;

struct CameraBuf;
struct CameraBufBuilder;
struct CameraBufT;

inline const flatbuffers::TypeTable *IntrinsicsBufTypeTable();

inline const flatbuffers::TypeTable *ExtrinsicsBufTypeTable();

inline const flatbuffers::TypeTable *DistortionCoeffsBufTypeTable();

inline const flatbuffers::TypeTable *CameraBufTypeTable();

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) IntrinsicsBuf FLATBUFFERS_FINAL_CLASS {
 private:
  double fx_;
  double fy_;
  double cx_;
  double cy_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntrinsicsBufTypeTable();
  }
  IntrinsicsBuf()
      : fx_(0),
        fy_(0),
        cx_(0),
        cy_(0) {
  }
  IntrinsicsBuf(double _fx, double _fy, double _cx, double _cy)
      : fx_(flatbuffers::EndianScalar(_fx)),
        fy_(flatbuffers::EndianScalar(_fy)),
        cx_(flatbuffers::EndianScalar(_cx)),
        cy_(flatbuffers::EndianScalar(_cy)) {
  }
  double fx() const {
    return flatbuffers::EndianScalar(fx_);
  }
  void mutate_fx(double _fx) {
    flatbuffers::WriteScalar(&fx_, _fx);
  }
  double fy() const {
    return flatbuffers::EndianScalar(fy_);
  }
  void mutate_fy(double _fy) {
    flatbuffers::WriteScalar(&fy_, _fy);
  }
  double cx() const {
    return flatbuffers::EndianScalar(cx_);
  }
  void mutate_cx(double _cx) {
    flatbuffers::WriteScalar(&cx_, _cx);
  }
  double cy() const {
    return flatbuffers::EndianScalar(cy_);
  }
  void mutate_cy(double _cy) {
    flatbuffers::WriteScalar(&cy_, _cy);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return fx();
    else if constexpr (Index == 1) return fy();
    else if constexpr (Index == 2) return cx();
    else if constexpr (Index == 3) return cy();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(IntrinsicsBuf, 32);

struct IntrinsicsBuf::Traits {
  using type = IntrinsicsBuf;
  static constexpr auto name = "IntrinsicsBuf";
  static constexpr auto fully_qualified_name = "ruff.photogrammetry.IntrinsicsBuf";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "fx",
    "fy",
    "cx",
    "cy"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ExtrinsicsBuf FLATBUFFERS_FINAL_CLASS {
 private:
  double rotation_[9];
  double translation_[3];

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExtrinsicsBufTypeTable();
  }
  ExtrinsicsBuf()
      : rotation_(),
        translation_() {
  }
  ExtrinsicsBuf(flatbuffers::span<const double, 9> _rotation, flatbuffers::span<const double, 3> _translation) {
    flatbuffers::CastToArray(rotation_).CopyFromSpan(_rotation);
    flatbuffers::CastToArray(translation_).CopyFromSpan(_translation);
  }
  const flatbuffers::Array<double, 9> *rotation() const {
    return &flatbuffers::CastToArray(rotation_);
  }
  flatbuffers::Array<double, 9> *mutable_rotation() {
    return &flatbuffers::CastToArray(rotation_);
  }
  const flatbuffers::Array<double, 3> *translation() const {
    return &flatbuffers::CastToArray(translation_);
  }
  flatbuffers::Array<double, 3> *mutable_translation() {
    return &flatbuffers::CastToArray(translation_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return rotation();
    else if constexpr (Index == 1) return translation();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(ExtrinsicsBuf, 96);

struct ExtrinsicsBuf::Traits {
  using type = ExtrinsicsBuf;
  static constexpr auto name = "ExtrinsicsBuf";
  static constexpr auto fully_qualified_name = "ruff.photogrammetry.ExtrinsicsBuf";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "rotation",
    "translation"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DistortionCoeffsBuf FLATBUFFERS_FINAL_CLASS {
 private:
  double radial_[3];
  double tangential_[2];

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DistortionCoeffsBufTypeTable();
  }
  DistortionCoeffsBuf()
      : radial_(),
        tangential_() {
  }
  DistortionCoeffsBuf(flatbuffers::span<const double, 3> _radial, flatbuffers::span<const double, 2> _tangential) {
    flatbuffers::CastToArray(radial_).CopyFromSpan(_radial);
    flatbuffers::CastToArray(tangential_).CopyFromSpan(_tangential);
  }
  const flatbuffers::Array<double, 3> *radial() const {
    return &flatbuffers::CastToArray(radial_);
  }
  flatbuffers::Array<double, 3> *mutable_radial() {
    return &flatbuffers::CastToArray(radial_);
  }
  const flatbuffers::Array<double, 2> *tangential() const {
    return &flatbuffers::CastToArray(tangential_);
  }
  flatbuffers::Array<double, 2> *mutable_tangential() {
    return &flatbuffers::CastToArray(tangential_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return radial();
    else if constexpr (Index == 1) return tangential();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(DistortionCoeffsBuf, 40);

struct DistortionCoeffsBuf::Traits {
  using type = DistortionCoeffsBuf;
  static constexpr auto name = "DistortionCoeffsBuf";
  static constexpr auto fully_qualified_name = "ruff.photogrammetry.DistortionCoeffsBuf";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "radial",
    "tangential"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct CameraBufT : public flatbuffers::NativeTable {
  typedef CameraBuf TableType;
  std::unique_ptr<ruff::photogrammetry::IntrinsicsBuf> intrinsics{};
  std::unique_ptr<ruff::photogrammetry::ExtrinsicsBuf> extrinsics{};
  std::unique_ptr<ruff::photogrammetry::DistortionCoeffsBuf> dist_coeffs{};
  CameraBufT() = default;
  CameraBufT(const CameraBufT &o);
  CameraBufT(CameraBufT&&) FLATBUFFERS_NOEXCEPT = default;
  CameraBufT &operator=(CameraBufT o) FLATBUFFERS_NOEXCEPT;
};

struct CameraBuf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CameraBufT NativeTableType;
  typedef CameraBufBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CameraBufTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTRINSICS = 4,
    VT_EXTRINSICS = 6,
    VT_DIST_COEFFS = 8
  };
  const ruff::photogrammetry::IntrinsicsBuf *intrinsics() const {
    return GetStruct<const ruff::photogrammetry::IntrinsicsBuf *>(VT_INTRINSICS);
  }
  ruff::photogrammetry::IntrinsicsBuf *mutable_intrinsics() {
    return GetStruct<ruff::photogrammetry::IntrinsicsBuf *>(VT_INTRINSICS);
  }
  const ruff::photogrammetry::ExtrinsicsBuf *extrinsics() const {
    return GetStruct<const ruff::photogrammetry::ExtrinsicsBuf *>(VT_EXTRINSICS);
  }
  ruff::photogrammetry::ExtrinsicsBuf *mutable_extrinsics() {
    return GetStruct<ruff::photogrammetry::ExtrinsicsBuf *>(VT_EXTRINSICS);
  }
  const ruff::photogrammetry::DistortionCoeffsBuf *dist_coeffs() const {
    return GetStruct<const ruff::photogrammetry::DistortionCoeffsBuf *>(VT_DIST_COEFFS);
  }
  ruff::photogrammetry::DistortionCoeffsBuf *mutable_dist_coeffs() {
    return GetStruct<ruff::photogrammetry::DistortionCoeffsBuf *>(VT_DIST_COEFFS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return intrinsics();
    else if constexpr (Index == 1) return extrinsics();
    else if constexpr (Index == 2) return dist_coeffs();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ruff::photogrammetry::IntrinsicsBuf>(verifier, VT_INTRINSICS, 8) &&
           VerifyField<ruff::photogrammetry::ExtrinsicsBuf>(verifier, VT_EXTRINSICS, 8) &&
           VerifyField<ruff::photogrammetry::DistortionCoeffsBuf>(verifier, VT_DIST_COEFFS, 8) &&
           verifier.EndTable();
  }
  CameraBufT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CameraBufT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CameraBuf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraBufT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CameraBufBuilder {
  typedef CameraBuf Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_intrinsics(const ruff::photogrammetry::IntrinsicsBuf *intrinsics) {
    fbb_.AddStruct(CameraBuf::VT_INTRINSICS, intrinsics);
  }
  void add_extrinsics(const ruff::photogrammetry::ExtrinsicsBuf *extrinsics) {
    fbb_.AddStruct(CameraBuf::VT_EXTRINSICS, extrinsics);
  }
  void add_dist_coeffs(const ruff::photogrammetry::DistortionCoeffsBuf *dist_coeffs) {
    fbb_.AddStruct(CameraBuf::VT_DIST_COEFFS, dist_coeffs);
  }
  explicit CameraBufBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CameraBuf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraBuf>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraBuf> CreateCameraBuf(
    flatbuffers::FlatBufferBuilder &_fbb,
    const ruff::photogrammetry::IntrinsicsBuf *intrinsics = nullptr,
    const ruff::photogrammetry::ExtrinsicsBuf *extrinsics = nullptr,
    const ruff::photogrammetry::DistortionCoeffsBuf *dist_coeffs = nullptr) {
  CameraBufBuilder builder_(_fbb);
  builder_.add_dist_coeffs(dist_coeffs);
  builder_.add_extrinsics(extrinsics);
  builder_.add_intrinsics(intrinsics);
  return builder_.Finish();
}

struct CameraBuf::Traits {
  using type = CameraBuf;
  static auto constexpr Create = CreateCameraBuf;
  static constexpr auto name = "CameraBuf";
  static constexpr auto fully_qualified_name = "ruff.photogrammetry.CameraBuf";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "intrinsics",
    "extrinsics",
    "dist_coeffs"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

flatbuffers::Offset<CameraBuf> CreateCameraBuf(flatbuffers::FlatBufferBuilder &_fbb, const CameraBufT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CameraBufT::CameraBufT(const CameraBufT &o)
      : intrinsics((o.intrinsics) ? new ruff::photogrammetry::IntrinsicsBuf(*o.intrinsics) : nullptr),
        extrinsics((o.extrinsics) ? new ruff::photogrammetry::ExtrinsicsBuf(*o.extrinsics) : nullptr),
        dist_coeffs((o.dist_coeffs) ? new ruff::photogrammetry::DistortionCoeffsBuf(*o.dist_coeffs) : nullptr) {
}

inline CameraBufT &CameraBufT::operator=(CameraBufT o) FLATBUFFERS_NOEXCEPT {
  std::swap(intrinsics, o.intrinsics);
  std::swap(extrinsics, o.extrinsics);
  std::swap(dist_coeffs, o.dist_coeffs);
  return *this;
}

inline CameraBufT *CameraBuf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CameraBufT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CameraBuf::UnPackTo(CameraBufT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = intrinsics(); if (_e) _o->intrinsics = std::unique_ptr<ruff::photogrammetry::IntrinsicsBuf>(new ruff::photogrammetry::IntrinsicsBuf(*_e)); }
  { auto _e = extrinsics(); if (_e) _o->extrinsics = std::unique_ptr<ruff::photogrammetry::ExtrinsicsBuf>(new ruff::photogrammetry::ExtrinsicsBuf(*_e)); }
  { auto _e = dist_coeffs(); if (_e) _o->dist_coeffs = std::unique_ptr<ruff::photogrammetry::DistortionCoeffsBuf>(new ruff::photogrammetry::DistortionCoeffsBuf(*_e)); }
}

inline flatbuffers::Offset<CameraBuf> CameraBuf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraBufT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCameraBuf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CameraBuf> CreateCameraBuf(flatbuffers::FlatBufferBuilder &_fbb, const CameraBufT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CameraBufT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _intrinsics = _o->intrinsics ? _o->intrinsics.get() : nullptr;
  auto _extrinsics = _o->extrinsics ? _o->extrinsics.get() : nullptr;
  auto _dist_coeffs = _o->dist_coeffs ? _o->dist_coeffs.get() : nullptr;
  return ruff::photogrammetry::CreateCameraBuf(
      _fbb,
      _intrinsics,
      _extrinsics,
      _dist_coeffs);
}

inline const flatbuffers::TypeTable *IntrinsicsBufTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16, 24, 32 };
  static const char * const names[] = {
    "fx",
    "fy",
    "cx",
    "cy"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExtrinsicsBufTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 1, -1 },
    { flatbuffers::ET_DOUBLE, 1, -1 }
  };
  static const int16_t array_sizes[] = { 9, 3,  };
  static const int64_t values[] = { 0, 72, 96 };
  static const char * const names[] = {
    "rotation",
    "translation"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, array_sizes, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DistortionCoeffsBufTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 1, -1 },
    { flatbuffers::ET_DOUBLE, 1, -1 }
  };
  static const int16_t array_sizes[] = { 3, 2,  };
  static const int64_t values[] = { 0, 24, 40 };
  static const char * const names[] = {
    "radial",
    "tangential"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, array_sizes, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CameraBufTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ruff::photogrammetry::IntrinsicsBufTypeTable,
    ruff::photogrammetry::ExtrinsicsBufTypeTable,
    ruff::photogrammetry::DistortionCoeffsBufTypeTable
  };
  static const char * const names[] = {
    "intrinsics",
    "extrinsics",
    "dist_coeffs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ruff::photogrammetry::CameraBuf *GetCameraBuf(const void *buf) {
  return flatbuffers::GetRoot<ruff::photogrammetry::CameraBuf>(buf);
}

inline const ruff::photogrammetry::CameraBuf *GetSizePrefixedCameraBuf(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ruff::photogrammetry::CameraBuf>(buf);
}

inline CameraBuf *GetMutableCameraBuf(void *buf) {
  return flatbuffers::GetMutableRoot<CameraBuf>(buf);
}

inline ruff::photogrammetry::CameraBuf *GetMutableSizePrefixedCameraBuf(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<ruff::photogrammetry::CameraBuf>(buf);
}

inline bool VerifyCameraBufBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ruff::photogrammetry::CameraBuf>(nullptr);
}

inline bool VerifySizePrefixedCameraBufBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ruff::photogrammetry::CameraBuf>(nullptr);
}

inline void FinishCameraBufBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ruff::photogrammetry::CameraBuf> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCameraBufBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ruff::photogrammetry::CameraBuf> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ruff::photogrammetry::CameraBufT> UnPackCameraBuf(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ruff::photogrammetry::CameraBufT>(GetCameraBuf(buf)->UnPack(res));
}

inline std::unique_ptr<ruff::photogrammetry::CameraBufT> UnPackSizePrefixedCameraBuf(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ruff::photogrammetry::CameraBufT>(GetSizePrefixedCameraBuf(buf)->UnPack(res));
}

}  // namespace photogrammetry
}  // namespace ruff

#endif  // FLATBUFFERS_GENERATED_CAMERA_RUFF_PHOTOGRAMMETRY_H_
